import type { ProjectState, Ticket } from "./schemas";

/**
 * Export project as JSON
 */
export function exportJSON(state: ProjectState): string {
  return JSON.stringify(state, null, 2);
}

/**
 * Export tickets as CSV
 */
export function exportCSV(state: ProjectState): string {
  const headers = [
    "ID",
    "Title",
    "Description",
    "Acceptance Criteria",
    "Effort Points",
    "Use Case",
    "Priority",
    "Labels",
    "Dependencies",
  ];

  const rows = state.tickets.map((ticket: Ticket) => [
    ticket.id,
    ticket.title,
    ticket.description.replace(/"/g, '""'), // Escape quotes
    ticket.acceptanceCriteria.join(" | ").replace(/"/g, '""'),
    ticket.effortPoints.toString(),
    ticket.useCase.replace(/"/g, '""'),
    ticket.priority,
    ticket.labels.join(", "),
    ticket.dependencies.join(", "),
  ]);

  const csvContent = [
    headers.map(h => `"${h}"`).join(","),
    ...rows.map(row => row.map(cell => `"${cell}"`).join(",")),
  ].join("\n");

  return csvContent;
}

/**
 * Export project as Markdown
 */
export function exportMarkdown(state: ProjectState): string {
  let md = `# ${state.requirements.projectName}\n\n`;
  md += `${state.requirements.summary}\n\n`;

  md += `## Requirements\n\n`;
  
  if (state.requirements.goals.length > 0) {
    md += `### Goals\n`;
    state.requirements.goals.forEach(goal => {
      md += `- ${goal}\n`;
    });
    md += `\n`;
  }

  if (state.requirements.constraints.length > 0) {
    md += `### Constraints\n`;
    state.requirements.constraints.forEach(constraint => {
      md += `- ${constraint}\n`;
    });
    md += `\n`;
  }

  if (state.requirements.features.length > 0) {
    md += `### Features\n`;
    state.requirements.features.forEach(feature => {
      md += `- ${feature}\n`;
    });
    md += `\n`;
  }

  md += `## Development Tickets\n\n`;
  md += `Total tickets: ${state.tickets.length}\n\n`;

  // Group by priority
  const priorities = ["P1", "P2", "P3"] as const;
  priorities.forEach(priority => {
    const ticketsInPriority = state.tickets.filter(t => t.priority === priority);
    if (ticketsInPriority.length > 0) {
      md += `### Priority ${priority}\n\n`;
      ticketsInPriority.forEach(ticket => {
        md += `#### ${ticket.id}: ${ticket.title}\n\n`;
        md += `**Effort:** ${ticket.effortPoints} points | **Use Case:** ${ticket.useCase}\n\n`;
        if (ticket.labels.length > 0) {
          md += `**Labels:** ${ticket.labels.join(", ")}\n\n`;
        }
        if (ticket.dependencies.length > 0) {
          md += `**Dependencies:** ${ticket.dependencies.join(", ")}\n\n`;
        }
        md += `**Description:**\n${ticket.description}\n\n`;
        md += `**Acceptance Criteria:**\n`;
        ticket.acceptanceCriteria.forEach(criterion => {
          md += `- ${criterion}\n`;
        });
        md += `\n`;
      });
    }
  });

  md += `## Summary\n\n`;
  md += `**Total Effort:** ${state.tickets.reduce((sum, t) => sum + t.effortPoints, 0)} story points\n\n`;
  
  md += `---\n\n`;
  md += `*Generated by Sprintify on ${new Date(state.createdAt).toLocaleDateString()}*\n`;
  md += `*Cost: ${state.cost.tokensIn.toLocaleString()} tokens in, ${state.cost.tokensOut.toLocaleString()} tokens out, $${state.cost.usd.toFixed(4)}*\n`;

  return md;
}

